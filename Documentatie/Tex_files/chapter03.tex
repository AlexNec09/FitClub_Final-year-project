\chapter{Proiectarea aplicației}
Aplicația FitClub este bazată pe doua mari module:

\paragraph{•  RESTful API Web Service pe partea de server -}Acesta este creierul aplicației în sine unde se fac operațiile CRUD și accesăm API-uri înainte de a returna date structurate aplicației client-side.

\paragraph{•  Partea de client care interacționează cu Web Service -}Se realizează apeluri către Web Service-ul descris anterior, și se conectează elementele de UI pentru a accepta datele pe care ar trebui să le vadă fiecare tip de utilizator.\newline

\section{Implementarea server-ului web}

\subsection{Securitatea aplicației}
\lstset{frame=tb}

Pentru a spori securitatea, am configurat manual comportamentul prin care Spring Security interacționează cu aplicația. Implementarea corespunzătoare se află în clasa \code{SecurityConfiguration}, unde am suprascris metoda \code{configure} din care putem accesa obiectul corespunzător HttpSecurity care este obiectul de configurare utilizat de Spring Security, și în acest mod, putem să-i modificăm comportamentul. În mod implicit, Spring Security permite CSRF\footnote{Cross-site request forgery}, care este la bază un token generat de back-end care caută acest token pentru a fi adăugat la cererile ulterioare de tip POST sau PUT generate de client. Am decis să nu folosesc acest token, deoarece aplicația folosește JWT.\newline

Pe partea de autorizare, a fost necesar, de asemenea, să securizez endpoint-urile necesare pentru a evita cazul în care Spring să respingă cererile ulterioare, returnând codul 403 FORBIDDEN.\newline
În acest caz, am folosit \code{http.authorizeRequests().antMatchers()} pentru a aplica autorizația la una sau mai multe căi, reprezentate prin tipul de cerere (HTTPMethod) și URL-ul corespunzător, pe care le specific în \code{antMatchers()}.\newline

 \begin{lstlisting}[language=Java]
	http.
		authorizeRequests().and()
		.exceptionHandling()
		.authenticationEntryPoint(unauthorizedHandler)
		.and()
		.sessionManagement()
		.sessionCreationPolicy(SessionCreationPolicy.STATELESS)
		.and()
		.authorizeRequests()
		.antMatchers("/images/**", "/api/1.0/users/find/{search}", "/api/1.0/auth/**").permitAll()
		.antMatchers(HttpMethod.PUT, "/api/1.0/users/{id:[0-9]+}").authenticated()
		.antMatchers(HttpMethod.GET, "/api/1.0/users/{username}/posts").authenticated()
		.antMatchers(HttpMethod.POST, "/api/1.0/posts/upload").authenticated()
		.antMatchers(HttpMethod.POST, "/api/1.0/posts/**").authenticated()
		.antMatchers(HttpMethod.DELETE, "/api/1.0/posts/{id:[0-9]+}").authenticated()
		.antMatchers(HttpMethod.PUT, "/api/1.0/posts/{id:[0-9]+}/like").authenticated()
		.antMatchers(HttpMethod.PUT, "/api/1.0/posts/{id:[0-9]+}/dislike").authenticated()
		.antMatchers("/api/1.0/users/{id:[0-9]+}/follow", "/api/1.0/users/{id:[0-9]+}/unfollow").authenticated()
		.antMatchers(HttpMethod.GET, "/api/1.0/posts/{id:[0-9]+}").authenticated()
		.antMatchers(HttpMethod.GET, "/api/1.0/posts/**").authenticated()
		.and().authorizeRequests().anyRequest().permitAll();
\end{lstlisting}

În codul de mai sus, se remarcă faptul că ordinea din această configurare este foarte importantă, deoarece dorim să asigurăm totuși un acces limitat unui vizitator atunci când accesează site-ul. Astfel, i se va permite să se autentifice, să caute prin utilizatorii deja existenți și să le vadă poza de profil. De asemenea, pot exista și endpoint-uri care sunt permise să treacă de partea de validare a Spring Security, însă în cadrul acestei aplicații, funcționalitățile de bază necesită verificări de autorizare din partea fiecărui utilizator.\newline

În contextul folosirii JSON Web Token, am personalizat și modul în care aplicația va gestiona excepțiile ce vor rezulta din punctul de intrare pentru autentificare, definit în cadrul clasei \code{JwtAuthenticationEntryPoint}. Pentru a oferi un context, acest punct de intrare pentru autentificare gestionează excepțiile care trebuie aruncate atunci când un utilizator încearcă să acceseze o resursă care necesită autentificare, cum ar fi posibilitatea de a vedea postările unui alt utilizator.\newline

În ceea ce privește gestionarea sesiunii, am optat pentru configurarea \code{SessionCreationPolicy.STATELESS}, deoarece acesta este un REST API și nu am dorit ca acesta să salveze sesiuni sau cookie-uri, acesta fiind și principalul motiv pentru care am optat să folosesc JWT, astfel încât serverul să nu fie nevoit să rețină sesiunea și de fiecare dată când o cerere vine cu un token valid, serverul o va prelucra corespunzător si va trimite un răspuns. Token-urile vor avea date de expirare, informații succinte despre utilizator, însă, la bază, aplicația folosește un JWT din dorința de a ne asigura că nicio stare nu se va salva pe server și pentru a valida cererile ce vin de pe partea de client. În schimb, sesiunea se va salva prin intermediul React Redux, indiferent dacă utilizatorul este sau nu autentificat.\newline

De asemenea, în cadrul fișierului de configurări, am ales sa evit injectarea directa a valorilor, și am creat o clasă denumita \code{AppConfiguration} pentru aceste proprietăți personalizate. Presupunând că este necesară o proprietate pe care dorim să o numim \code{uploadsPath} în cadrul aplicației, atunci, pentru ca Spring să o poată recunoaște în fișierul de configurări denumit \code{application.yml}, o vom scrie prin unirea cuvintelor cu liniuță, adica \code{uploads-path}.
Pentru această clasă, trebuie, de asemenea, să folosim adnotarea \code{@ConfigurationProperties}, care este necesară pentru a lega proprietățile externe de acest obiect și putem, de asemenea, să definim un prefix pentru aceste proprietăți personalizate, cum ar fi "fitclub". Concret, în fișierul de configurări \code{application.yml}, valoarea setată prin \code{fitclub.uploads-path} va seta așadar valoarea proprietății personalizate din clasă.\newline 
Așadar, utilitatea acestei clase se rezumă la accesarea rapidă a căii unde se vor salva atașamentele ce pot veni de pe partea de client, fie din schimbarea pozei de profil a utilizatorului sau din atașarea unei imagini la o postare.\newline

\subsection{Utilizarea JWT}

Implementarea JWT este relevantă în cadrul configurării pentru autentificarea fără stare, folosind un token JWT. Pentru a personaliza Spring Security în acest sens, am adăugat configurări suplimentare în clasa de configurare prezentată anterior astfel încât să configurăm managerul de autentificare cu furnizorul corect.\newline

Pentru ca utilizatorul să se poată autentifice cu succes pe site, avem nevoie să încărcăm toate datele acestuia. În documentația Spring, \code{UserDetailsService} este descrisă ca o interfață de bază care încarcă datele specifice utilizatorului. În cele mai multe cazuri de utilizare, furnizorii de autentificare extrag informațiile privind identitatea utilizatorului pe baza acreditărilor dintr-o bază de date și apoi efectuează validarea. Deoarece acest caz de utilizare este atât de comun, dezvoltatorii Spring au decis să îl extragă ca o interfață separată, care expune funcția unică \code{loadUserByUsername} acceptă numele de utilizator ca parametru și returnează obiectul de identitate al utilizatorului.\newline

În implementarea acestei aplicații, am optat sa construiesc o clasă nouă, numită \code{CustomUserDetailsService} care să extindă această interfață, astfel încât să pot avea acces la anumite configurări suplimentare.\newline

 \begin{lstlisting}[language=Java]
	@Override
	public UserDetails loadUserByUsername(String username)
	throws UsernameNotFoundException {
		User user = userRepository.findByUsername(username);
		if (user == null) {
			throw new UsernameNotFoundException("User not found with username: " + username);
		}
		return UserPrincipal.create(user);
	}
\end{lstlisting}
\bigskip

După autentificare, ar putea fi necesar să verificăm credențialele utilizatorului, în cazul în care un hacker poate fura un token validat printr-un atac și îl poate injecta într-o cerere abuzivă. În acest context, Spring Security furnizează clasa \code{UsernamePasswordAuthenticationFilter} pentru a ajuta la efectuarea validării credențialelor, prin faptul că obținem acces la identitatea utilizatorului pentru a efectua autorizarea, iar extragerea acesteia are loc în cadrul filtrului JWT pe baza token-ului JWT furnizat.\newline
Așadar, am creat clasa \code{UserPrincipal} care implementează interfața \code{UserDetails} pentru a facilita \code{UsernamePasswordAuthenticationFilter}.\newline

După autentificarea și autorizarea credențialelor utilizatorului, aplicația trebuie să gestioneze excepțiile în timpul acestor procese. Pentru a face acest lucru posibil, am creat o clasă numită \code{JwtAuthenticationEntryPoint}  care să extindă \code{AuthenticationEntryPoint} și care suprascrie metoda \code{commence} pentru a personaliza mesajele de returnare.\newline

\begin{lstlisting}[language=Java]
	@Component
	public class JwtAuthenticationEntryPoint implements AuthenticationEntryPoint {
		
		private static final Logger logger = LoggerFactory.getLogger(JwtAuthenticationEntryPoint.class);
		@Override
		public void commence(HttpServletRequest httpServletRequest,
		HttpServletResponse httpServletResponse,
		AuthenticationException e) throws IOException, ServletException {
			logger.error("Responding with unauthorized error. Message - {}", e.getMessage());
			httpServletResponse.sendError(HttpServletResponse.SC_UNAUTHORIZED, e.getMessage());
		}
	}
\end{lstlisting}
\bigskip
În general, în cadrul acestei clase vor fi capturate excepții de tip token invalid (neautorizat) și credențiale invalide.\newline

\subsection{Distribuirea postărilor}



\label{chap:03}